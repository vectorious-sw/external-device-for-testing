#ifndef PROTOCOLAPP_H
#define PROTOCOLAPP_H

//#include "vlapConfig.h"
#include "uartDll.h"
#include "config.h"
#include "aescbc.h"
//#include "events.h"

// D E F I N I T I O N S 
#define PROTOCOLAPP_PROTOCOL_VERSION            0x03
#define PROTOCOLAPP_COMMANDS_AND_REQUESTS_BASE          0x8000



// EVENT: Generated from the VLAPex towards the cloud, Answered by Ack/Nack
// CMD:   Generated by the cloud, answered by Ack/Nack
// REQ:   Generated by the cloud. answered by Event      
// T Y P E S
typedef enum { PROTOCOLAPP_SERVER_ADDRESS = 0, PROTOCOLAPP_VLAPEX_ADDRESS = 1} PROTOCOLAPP_ADD_T;
typedef enum uint16_t {
  // E V E N T S 
            PROTOCOLAPP_GENERAL_ACK_EVENT =0,
            PROTOCOLAPP_GENERAL_NACK_EVENT=1,
            PROTOCOLAPP_GENERAL_SYSTEM_UP_EVENT=2,


            PROTOCOLAPP_POWER_BATT_LOW_EVENT=3,        
            PROTOCOLAPP_POWER_BATT_NORMAL_EVENT=4,
            PROTOCOLAPP_POWER_BATT_HIGH_EVENT=5,
            PROTOCOLAPP_POWER_DC_PLUG_CONNECTED_EVENT=6,
            PROTOCOLAPP_POWER_DC_PLUG_DISCONECTED_EVENT=7,
            PROTOCOLAPP_POWER_DC_FAULT_EVENT=8,
            PROTOCOLAPP_POWER_DC_POWER_OFF_EVENT=9,

            PROTOCOLAPP_MEASUREMENT_ABORTED_SHORT_PUSH_BUTTON_EVENT=10,
            PROTOCOLAPP_MEASUREMENT_ABORTED_BELT_OPEN_EVENT=11,        
            PROTOCOLAPP_MEASUREMENT_ABORTED_BATTERY_LEVEL_EVENT=12,        
            PROTOCOLAPP_MEASUREMENT_ENDED_EVENT=13,      
            PROTOCOLAPP_MEASUREMENT_FAILED_EVENT=14,

            PROTOCOLAPP_CONFIGURATION_DOWNLOAD_REQ=15,
            PROTOCOLAPP_CONFIGURATION_CHANGE_EVENT=16,

            PROTOCOLAPP_CHARGING_STARTED_EVENT = 17,
            PROTOCOLAPP_CHARGING_ENDED_EVENT = 18,
            PROTOCOLAPP_GENERAL_OPC_EVENT = 19,
            PROTOCOLAPP_GENERAL_KEEP_ALIVE_EVENT = 20,
            PROTOCOLAPP_GENERAL_NURSE_MODE_END_EVENT = 21,
            
            PROTOCOLAPP_MEASUREMENT_ABORTED_CHARGING_EVENT=22,
            PROTOCOLAPP_MEASUREMENT_ABORTED_TEMPERATURE_LEVEL_EVENT=23,
            PROTOCOLAPP_GENERAL_CORRUPTED_EVENT=24,
            PROTOCOLAPP_MEASUREMENT_ABORTED_TIMEOUT_EVENT=25,
            PROTOCOLAPP_FW_UPGRADE_CHUNK_REQ = 26,
            PROTOCOLAPP_FW_UPGRADE_CHUNK_ABORT_CMD = 27,
  
  
#ifdef VMIC_PROGRAMMER              
  PROTOCOLAPP_VMIC_PROGRAMMER_EVENT                         =       900,           
  
#endif        
  // C O M M A N D S   AND   R E Q U E S T S
  
  
  PROTOCOLAPP_CONFIGURATION_DOWNLOAD_RESP  = PROTOCOLAPP_COMMANDS_AND_REQUESTS_BASE,             // Sent as response to PROTOCOLAPP_CONFIGURATION_DOWNLOAD_REQ
  PROTOCOLAPP_CONFIGURATION_DOWNLOAD_NOUPDATE_RESP   = PROTOCOLAPP_COMMANDS_AND_REQUESTS_BASE +1,
  PROTOCOLAPP_FXXXX_IRMWARE_UPGRADE_START_RESP          = PROTOCOLAPP_COMMANDS_AND_REQUESTS_BASE +2,           // 
  PROTOCOLAPP_CONFIGURATION_UPDATE_CMD = PROTOCOLAPP_COMMANDS_AND_REQUESTS_BASE +3,           // Answered by Ack/Nack followed by PROTOCOLAPP_CONFIGURATION_CHANGE_EVENT
  PROTOCOLAPP_FW_DOWNLOAD_CMD          = PROTOCOLAPP_COMMANDS_AND_REQUESTS_BASE +4,           // Answered by Ack/Nack followed by PROTOCOLAPP_CONFIGURATION_CHANGE_EVENT
  PROTOCOLAPP_STATUS_GET_CMD           = PROTOCOLAPP_COMMANDS_AND_REQUESTS_BASE +5,           // Answered by Ack/Nack followed by PROTOCOLAPP_CONFIGURATION_CHANGE_EVENT
  PROTOCOLAPP_FW_UPGRADE_START_RESP    = PROTOCOLAPP_COMMANDS_AND_REQUESTS_BASE +6,           // Server initiates Firmware upgrade session
  PROTOCOLAPP_FW_UPGRADE_CHUNK_SEND_RESP  = PROTOCOLAPP_COMMANDS_AND_REQUESTS_BASE + 7,       // Server response with Firmware chunk upon chunk request  
  PROTOCOLAPP_LOG_MEMORY_CMD           = PROTOCOLAPP_COMMANDS_AND_REQUESTS_BASE + 8,          // Answered by Ack/Nacl
  PROTOCOLAPP_PORT_WRITE_CMD            = PROTOCOLAPP_COMMANDS_AND_REQUESTS_BASE + 9,          // Answered by Ack/Nacl
  
#ifdef VMIC_PROGRAMMER              
  PROTOCOLAPP_VMIC_PROGRAMMER_CMD = PROTOCOLAPP_COMMANDS_AND_REQUESTS_BASE + 100,               // Answered by Ack/Nack followed by PROTOCOLAPP_CONFIGURATION_CHANGE_EVENT
  PROTOCOLAPP_VMIC_PROGRAMMER_REQ = PROTOCOLAPP_COMMANDS_AND_REQUESTS_BASE + 101               // Answered by Ack/Nack followed by PROTOCOLAPP_CONFIGURATION_CHANGE_EVENT
#endif        
} PROTOCOLAPP_COMMANDS_T;


#pragma pack(1)
typedef union {
  struct {
    uint16_t MajorVersion:9;
    uint16_t MinorVersion:11;
    uint16_t BuildVersion:12;
  } FirmwareVersion;
  uint32_t FirmwareVersionValue;
} FirmwareVersion_T;

// Application Protocol Common Header (Upstream and Downstream)
#pragma pack(1)
typedef     struct {
  uint32_t TransmissionTimeStamp;                  // Place holder for the TransmissionTimeStamp, the server will override this parameter. In the future, if we will need more TDBs we can use it with some changes in the server
  uint8_t  TransmissionTimeStamp10mSec;            // Place holder for the TransmissionTimeStamp10mSec, the server will override this parameter. In the future, if we will need more TDBs we can use it with some changes in the server
  uint32_t EventTimeStamp;                         // Event TimeStamp (Number of seconds since Epoch, 1970-01-01 00:00:00 +0000 (UTC))
  uint8_t  EventTimeStamp10mSec;                   // Event TimeStamp (0-99 Tenth of a Second Resolution for the LinuxTimeOfDate seconds variable) 
  uint32_t MessageNumerator;                       // Message Numerator
  uint16_t SourceAddress;                          // Source Address: 0-Server, 1-Device 
  uint16_t DestinationAddress;                     // Destination Address: 0-Server, 1-Device
  uint8_t  ProtocolVersion;                        // The protocol's version
  uint16_t MessageOpCode;                          // Message Op Code
  uint32_t SessionID;                              // SessionID
  uint32_t HwVersion;                              // HwVersion
  FirmwareVersion_T FwVersion;                     // FwVersion
  uint32_t BleFwVersion;                           // BleFwVersion
  uint32_t BootloaderFwVersion;                    // BootloaderFwVersion
  uint32_t CRC32;                                  // CRC32
} ProtocolappHeader_t;



#pragma pack(1)
typedef     struct {
  uint32_t VbatVoltage;
	uint32_t FlashAddr;     // addr of record on flash for debugging 
} ProtocolappVbatData_t;  // used by spi flash event log


// This header is added to each message sent from the VLAPex towards the cloud 
#pragma pack(1)
typedef   struct  {
  uint8_t VlapExUniqId[12];                     // The External Device uniqueue Id as taken from the STM32 Uniqie Id registers 
  uint32_t VmicSerialNumber;                    // VMIC Serial Number
  uint32_t ConfigurationVersionId;              // Configuration file version ID
  uint16_t TBD0;									// Placeholder
  uint16_t TransmitterTemperature;               // NTC Temperature
  int32_t Longitude;                            // In degrees (+ = East) x 10^7 
  //int32_t AltitudeFromMsl;                      // In meters x 10^2
  uint32_t AbsolutePressure;
  uint16_t BattVoltage;                         // Battery voltage 
  uint16_t DcVoltage;                           // DC Voltage
  uint16_t ExternalTemperature;                 // External temperature
  int16_t accX;                                 // External x axis
  int16_t accY;                                 // External y axis
  int16_t accZ;                                 // External z axis
  union{
  struct {                                      // VLAPex Device Status bitmap       
    uint32_t DcPlugConnected:1;
    uint32_t ExternalPowerDetected:1;
  } Status;
  uint32_t StatusWord;
  } StatusUnion;
} ProtocolappUpStreamHeader_t;



// PROTOCOLAPP_GENERAL_ACK_EVENT
// PROTOCOLAPP_GENERAL_NACK_EVENT
#pragma pack(1)
typedef  struct  {
  uint16_t OpCode; // PROTOCOLAPP_GENERAL_ACK_EVENT
} ProtocolappGeneralResp_t;


 // PROTOCOLAPP_MEASUREMENT_ENDED_EVENT

typedef  enum  {MEASUREMENT_STATUS_OK=0, MEASUREMENT_STATUS_FAIL_FULL_LOG_MEM=1, MEASUREMENT_STATUS_FAIL_LOW_RECEPTION=2, MEASUREMENT_STATUS_FAIL_BAD_POSITION=3, MEASUREMENT_STATUS_FAIL_COUPLING_LOSS=4, MEASUREMENT_STATUS_FAIL_INVALID_MIN_MAX_VIOLATION=5 } MeasurementGeneralStatuyT;
typedef  enum  {BELT_STATUS_NOT_CONNECTED=0 ,BELT_STATUS_CONNECTED=1, BELT_STATUS_NOT_ON_BODY=2, BELT_STATUS_OVER_FOLDED=3} BeltStatusT;



#pragma pack(1)
typedef
union{
  struct { 
  uint32_t      vmicPressure    :21;
  uint32_t      TxCurrent           :11;
  } MeasureStruct;
  uint32_t MeasureWord;
} MeasurementAndTxCurrentT;


// PROTOCOLAPP_CONFIGURATION_UPLOAD_EVENT,
// PROTOCOLAPP_CONFIGURATION_CHANGE_EVENT,
#pragma pack(1)
typedef  struct  {
  ProtocolappUpStreamHeader_t UpStreamHeader;
  configConfigurationDb_t ConfigurationDb;
} ProtocolappConfigurationUploadEvent_t;




#define PROTOCOLAPP_GENERAL_ARRAY_SIZE                            100
#define PROTOCOLAPP_GENERAL_SMALL_ARRAY_SIZE                      60
#define PROTOCOLAPP_REAL_MEMS_SIZE                                1500


// PROTOCOLAPP_MEASUREMENT_ENDED_EVENT
#pragma pack(1)
typedef  struct  {
  uint16_t MeasurementId;
  uint16_t Psl;
  uint8_t  MeasurementGeneralStatus;  //byte
  uint8_t  MeasurementFailureReason;
  uint32_t AbsolutePressure;
  // TODO: To be replaced with accelerometer x,y,z
  uint32_t SequenceNumber;
  uint16_t RelaysState;
  uint16_t RelaysStateP2P;
  uint32_t EffectivBeltResistance;
  uint8_t  AnalogSensorVoltage;
  uint8_t  PowerGood;
  uint8_t  BeltStatus;
  uint32_t ReceptionRms;
  uint32_t FeedBackFrequency;
  uint32_t MeasurementDurationTime;
  int16_t  AccXStart;
  int16_t  AccYStart;
  int16_t  AccZStart;
  int16_t  AccXPreReal;
  int16_t  AccYPreReal;
  int16_t  AccZPreReal;
  int16_t  AccXEnd;
  int16_t  AccYEnd;
  int16_t  AccZEnd;
  int16_t  AccXP2P;
  int16_t  AccYP2P;
  int16_t  AccZP2P;
  MeasurementAndTxCurrentT Ic1[PROTOCOLAPP_GENERAL_ARRAY_SIZE];  // 42000
  MeasurementAndTxCurrentT Ic2[PROTOCOLAPP_GENERAL_ARRAY_SIZE];  // 42000
  MeasurementAndTxCurrentT Ic3[PROTOCOLAPP_GENERAL_ARRAY_SIZE];  // 42000
  MeasurementAndTxCurrentT Ref1[PROTOCOLAPP_GENERAL_ARRAY_SIZE]; // 80000
  MeasurementAndTxCurrentT T1[PROTOCOLAPP_GENERAL_ARRAY_SIZE];   // 96000
  MeasurementAndTxCurrentT RealMems[PROTOCOLAPP_REAL_MEMS_SIZE]; // 82000
  MeasurementAndTxCurrentT T2[PROTOCOLAPP_GENERAL_ARRAY_SIZE];     //96000
  MeasurementAndTxCurrentT Ref2[PROTOCOLAPP_GENERAL_ARRAY_SIZE];   // 80000
  MeasurementAndTxCurrentT Ic4[PROTOCOLAPP_GENERAL_ARRAY_SIZE];    // 42000
  MeasurementAndTxCurrentT Ic5[PROTOCOLAPP_GENERAL_ARRAY_SIZE];    // 42000
  MeasurementAndTxCurrentT Ic6[PROTOCOLAPP_GENERAL_ARRAY_SIZE];    // 42000
} ProtocolappMeasurementEndedEvent_t;


// PROTOCOLAPP_GENERAL_SYSTEM_UP_EVENT
#pragma pack(1)
typedef  struct  {
  struct
{
  uint32_t R0;
  uint32_t R1;
  uint32_t R2;
  uint32_t R3;
  uint32_t R12;
  uint32_t LR;
  uint32_t PC;
  uint32_t xPSR;
  uint32_t S0;
  uint32_t S1;
  uint32_t S2;
  uint32_t S3;
  uint32_t S4;
  uint32_t S5;
  uint32_t S6;
  uint32_t S7;
  uint32_t S8;
  uint32_t S9;
  uint32_t S10;
  uint32_t S11;
  uint32_t S12;
  uint32_t S13;
  uint32_t S14;
  uint32_t S15;
  uint32_t FPSCR1;
  uint32_t FPSCR0;
  uint32_t UserStackDump[50];
} ExceptionImage;
  uint32_t RCC_CSR;
  uint16_t commState;
  uint16_t eventsState;
  uint16_t chargerStatus;
  uint16_t measurementState;
  uint16_t ApplicationResetCause;
  uint8_t TaskName[20];

} ProtocolappPowerUpEventResetInfo_T;


// PROTOCOLAPP_GENERAL_NURSE_MODE_END_EVENT
#pragma pack(1)
typedef  struct  {
  uint32_t lastPlugInTime;
  uint32_t lastPlugOutTime;
  uint32_t endNurseModeTime;
  uint8_t NurseModeMaxIndicationLevel;
  uint32_t NurseModeStopTime;
  uint32_t NurseModeStartTime;
  uint32_t nurseModeDurationSeconds;
  uint8_t  EventTimeStamp10mSec;                   // Event TimeStamp (0-99 Tenth of a Second Resolution for the LinuxTimeOfDate seconds variable)
} ProtocolappNurseModeEndEvent_t;


// PROTOCOLAPP_POWER_BATT_LOW_EVENT   
// PROTOCOLAPP_POWER_BATT_NORMAL_EVENT
// PROTOCOLAPP_POWER_DC_PLUG_CONNECTED_EVENT
// PROTOCOLAPP_POWER_DC_PLUG_DISCONECTED_EVENT
// PROTOCOLAPP_POWER_DC_POWER_DETECTED_EVENT
// PROTOCOLAPP_POWER_DC_POWER_OFF_EVENT
#pragma pack(1)
typedef  struct  {
  ProtocolappUpStreamHeader_t UpStreamHeader;
} ProtocolappPowerEvent_t;


#pragma pack(1)
typedef  struct  {
      uint8_t LogMemId;
      uint8_t TailPtr1State;          // 0- Stop getting data out of the FIFO via Tail1, 1- Normal Processing
      uint8_t TailPtr2State;          // 0- Stop getting data out of the FIFO via Tail2, 1- Normal Processing
} ProtocolappLogMemoryStructCmd_t;



// E X T E R N A L    P R O T O T Y P E S
ReturnCode_T protocolappHandlePacket(uartdllChannel_t Channel, uint8_t * MessagePtr, uint32_t MessageLength);
void protocolappPowerUpInit();
ReturnCode_T protocolappMessageBuild(uartdllChannel_t Channel, uint32_t RequrstOrCommandSessionId, PROTOCOLAPP_COMMANDS_T messageOpCode, char * PayloadPtr, uint16_t PayloadLength, uint8_t PayloadMemFreeRequired, uint8_t **ReturnedMessagePtr, uint16_t *ReturnedMessageLengthPtr, uint8_t *ReturnedAddedPad);
uint8_t* protocolappUniqueIdPtrGet();
// I N T E R N A L   P R O T O T Y P E S
uint8_t* UniqueIdPtrGet();  
void protocolAppEventTest(void *v);
ReturnCode_T protocolappMessageBuildnNotViaFlash(uartdllChannel_t Channel, uint32_t RequrstOrCommandSessionId, PROTOCOLAPP_COMMANDS_T messageOpCode, char * PayloadRelatedDataPtr, uint16_t PayloadRelatedDataLength, uint8_t *OutputBufferPtr, uint16_t *ReturnedMessageLengthPtr, uint8_t *ReturnedAddedPad);
ReturnCode_T protocolappHeadersNetworkOrderFix(ProtocolappHeader_t* MessagePtr, ProtocolappHeader_t* MyAppHeader);


  
#endif
  
